<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Heads Up! Clone</title>
    <style>
        :root {
            --primary: #6c5ce7;
            --success: #00b894;
            --skip: #ff7675;
            --bg: #2d3436;
            --text: #ffffff;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* --- Screens --- */
        .screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.3s;
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .screen.active {
            opacity: 1;
            pointer-events: all;
            z-index: 10;
        }

        /* --- Orientation Lock Overlay --- */
        #rotate-message {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: #000;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
        }
        
        /* Only show rotate message in portrait */
        @media screen and (orientation: landscape) {
            #rotate-message { display: none; }
        }
        @media screen and (orientation: portrait) {
            .screen { display: none; }
        }

        /* --- UI Elements --- */
        h1 { font-size: 3rem; margin-bottom: 20px; text-transform: uppercase; letter-spacing: 2px; }
        p { font-size: 1.2rem; margin-bottom: 30px; text-align: center; max-width: 600px; color: #b2bec3; }

        button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.5rem;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s;
            margin: 10px;
        }

        button:active { transform: scale(0.95); }

        /* --- Game Screen --- */
        #game-screen { background-color: var(--primary); transition: background-color 0.2s; }
        #game-screen.correct { background-color: var(--success); }
        #game-screen.skip { background-color: var(--skip); }

        .card-word {
            font-size: 15vh; /* Huge text */
            font-weight: 800;
            text-align: center;
            line-height: 1.1;
            padding: 0 20px;
        }

        .timer {
            position: absolute;
            top: 20px;
            right: 30px;
            font-size: 2rem;
            font-weight: bold;
            background: rgba(0,0,0,0.2);
            padding: 10px 20px;
            border-radius: 20px;
        }

        .score-display {
            position: absolute;
            top: 20px;
            left: 30px;
            font-size: 2rem;
            font-weight: bold;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            font-size: 1rem;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* --- Debug Info (Hidden by default) --- */
        #debug {
            position: fixed;
            top: 0;
            left: 0;
            font-size: 10px;
            background: rgba(0,0,0,0.5);
            pointer-events: none;
            display: none; 
        }
    </style>
</head>
<body>

    <div id="rotate-message">
        <h1>üîÑ</h1>
        <h2>Please Rotate Your Device</h2>
        <p>This game must be played in Landscape mode.</p>
    </div>

    <div id="home-screen" class="screen active">
        <h1>Heads Up!</h1>
        <p>1. Rotate to Landscape.<br>2. Place phone on forehead.<br>3. Tilt DOWN for Correct, UP to Skip.</p>
        
        <div style="display:flex; flex-wrap:wrap; justify-content:center;">
            <button onclick="startGame('animals')">Animals ü¶Å</button>
            <button onclick="startGame('movies')">Movies üé¨</button>
            <button onclick="startGame('actions')">Act It Out üé≠</button>
        </div>
        
        <p style="font-size: 0.9rem; margin-top: 20px;">(Tap a button to request sensor permissions)</p>
    </div>

    <div id="calibration-screen" class="screen">
        <h1>Place on Forehead</h1>
        <p>Get ready! Calibrating sensor position...</p>
        <h2 id="countdown">3</h2>
    </div>

    <div id="game-screen" class="screen">
        <div class="score-display">Score: <span id="score">0</span></div>
        <div class="timer" id="timer">60</div>
        <div class="card-word" id="word-display">Word</div>
        <div class="instructions">Tilt Down: Correct &nbsp;&nbsp;‚Ä¢&nbsp;&nbsp; Tilt Up: Pass</div>
    </div>

    <div id="results-screen" class="screen">
        <h1>Time's Up!</h1>
        <p>You got</p>
        <h1 style="font-size: 6rem; margin: 0;" id="final-score">0</h1>
        <p>points</p>
        <button onclick="resetGame()">Play Again</button>
    </div>

    <div id="debug"></div>

    <script>
        // --- Data ---
        const decks = {
            animals: ['Lion', 'Tiger', 'Bear', 'Elephant', 'Giraffe', 'Monkey', 'Snake', 'Dog', 'Cat', 'Shark', 'Whale', 'Eagle', 'Penguin', 'Kangaroo'],
            movies: ['Titanic', 'Avatar', 'Star Wars', 'The Matrix', 'Frozen', 'Lion King', 'Jurassic Park', 'Harry Potter', 'Avengers', 'Shrek', 'Inception'],
            actions: ['Dancing', 'Swimming', 'Driving', 'Cooking', 'Sleeping', 'Fishing', 'Skiing', 'Boxing', 'Singing', 'Flying', 'Typing']
        };

        // --- State ---
        let currentDeck = [];
        let score = 0;
        let timeLeft = 60;
        let gameActive = false;
        let timerInterval;
        let sensorActive = false;

        // --- Motion Logic State ---
        let neutralGamma = 0; // The angle of the phone when on the forehead
        let lastState = 'neutral'; // 'neutral', 'up', 'down'
        const TILT_THRESHOLD = 30; // Degrees to tilt to trigger action
        const RESET_THRESHOLD = 10; // Degrees to return to to reset trigger

        // --- DOM Elements ---
        const screens = document.querySelectorAll('.screen');
        const wordDisplay = document.getElementById('word-display');
        const timerDisplay = document.getElementById('timer');
        const scoreDisplay = document.getElementById('score');
        const finalScoreDisplay = document.getElementById('final-score');
        const gameScreenEl = document.getElementById('game-screen');
        const debugEl = document.getElementById('debug');

        // --- Navigation ---
        function showScreen(id) {
            screens.forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        // --- Initialization ---
        async function startGame(category) {
            currentDeck = [...decks[category]];
            shuffle(currentDeck);
            score = 0;
            timeLeft = 60;
            
            // Request Permission (iOS 13+ requirement)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        startCalibration();
                    } else {
                        alert("Permission denied. We need motion sensors to play!");
                    }
                } catch (error) {
                    console.error(error);
                }
            } else {
                // Non-iOS 13+ devices
                startCalibration();
            }
        }

        // --- Calibration Phase ---
        function startCalibration() {
            showScreen('calibration-screen');
            let count = 3;
            const countEl = document.getElementById('countdown');
            countEl.innerText = count;

            // Start listening to sensors to get a baseline
            window.addEventListener('deviceorientation', handleOrientation);
            sensorActive = true;
            gameActive = false; // Don't trigger answers yet

            const countdownInterval = setInterval(() => {
                count--;
                countEl.innerText = count;
                if (count <= 0) {
                    clearInterval(countdownInterval);
                    captureNeutralPosition();
                    launchGame();
                }
            }, 1000);
        }

        // Capture the angle of the phone while it's resting on the forehead
        function captureNeutralPosition() {
            // We take the current gamma as the "zero" point.
            // Note: We rely on the last captured value in the handleOrientation loop
            // but since gameActive is false, it hasn't done anything yet.
            console.log("Calibrated Neutral Gamma: " + neutralGamma);
        }

        // --- Core Game Logic ---
        function launchGame() {
            showScreen('game-screen');
            gameActive = true;
            nextCard();
            updateTimer();
            
            timerInterval = setInterval(() => {
                timeLeft--;
                updateTimer();
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
        }

        function updateTimer() {
            timerDisplay.innerText = timeLeft;
        }

        function nextCard() {
            if (currentDeck.length === 0) {
                endGame();
                return;
            }
            // Reset background color
            gameScreenEl.className = 'screen active';
            wordDisplay.innerText = currentDeck.pop();
        }

        function handleAnswer(type) {
            if (type === 'correct') {
                score++;
                scoreDisplay.innerText = score;
                gameScreenEl.classList.add('correct');
                playSound('correct');
            } else {
                gameScreenEl.classList.add('skip');
                playSound('skip');
            }
            
            // Short delay to show color before next card
            gameActive = false; // Pause input
            setTimeout(() => {
                if (timeLeft > 0) {
                    gameActive = true;
                    nextCard();
                }
            }, 500);
        }

        function endGame() {
            gameActive = false;
            sensorActive = false;
            clearInterval(timerInterval);
            window.removeEventListener('deviceorientation', handleOrientation);
            finalScoreDisplay.innerText = score;
            showScreen('results-screen');
        }

        function resetGame() {
            showScreen('home-screen');
        }

        function shuffle(array) {
            array.sort(() => Math.random() - 0.5);
        }

        // --- Motion Physics Engine ---
        function handleOrientation(event) {
            // Gamma: Left-to-Right tilt in Portrait. 
            // In Landscape, Gamma acts as the Up/Down tilt (Looking at floor/ceiling).
            let gamma = event.gamma; 
            
            // Handle edge case where gamma jumps (sometimes happens at 90deg)
            if (gamma === null) return;

            // Calibration Logic:
            // If we are in the countdown phase, we constantly update 'neutralGamma' 
            // to be whatever the phone is currently at. The moment game starts, we stop updating it.
            if (!gameActive && sensorActive && document.getElementById('calibration-screen').classList.contains('active')) {
                neutralGamma = gamma;
                return;
            }

            if (!gameActive) return;

            // Calculate deviation from the calibrated neutral point
            let deviation = gamma - neutralGamma;

            // Orientation correction:
            // Depending on if the home button is left or right, the signs might flip.
            // However, usually:
            // Tilt Screen Down (Floor) -> Gamma Increases (Positive Deviation)
            // Tilt Screen Up (Ceiling) -> Gamma Decreases (Negative Deviation)
            
            // If window.orientation is -90 (Landscape Right), logic inverts.
            // Let's normalize it.
            if (window.orientation === 90) {
                deviation = deviation * -1;
            }

            // Debug text
            debugEl.innerHTML = `Neutral: ${neutralGamma.toFixed(1)} <br> Current: ${gamma.toFixed(1)} <br> Dev: ${deviation.toFixed(1)}`;

            // --- State Machine ---
            
            // 1. Check for triggers
            if (lastState === 'neutral') {
                // Check for Correct (Tilt Down / Forehead to Floor)
                if (deviation > TILT_THRESHOLD) {
                    lastState = 'down';
                    if(navigator.vibrate) navigator.vibrate(200);
                    handleAnswer('correct');
                }
                // Check for Skip (Tilt Up / Forehead to Ceiling)
                else if (deviation < -TILT_THRESHOLD) {
                    lastState = 'up';
                    if(navigator.vibrate) navigator.vibrate([50, 50, 50]);
                    handleAnswer('skip');
                }
            }
            
            // 2. Check for Reset (Must return to middle before triggering again)
            else if (lastState === 'down' || lastState === 'up') {
                if (deviation > -RESET_THRESHOLD && deviation < RESET_THRESHOLD) {
                    lastState = 'neutral';
                }
            }
        }

        // --- Audio Feedback (Optional simple beeps) ---
        // Browsers block auto-audio, but since user clicked "Start", this usually works.
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            if (type === 'correct') {
                osc.frequency.value = 600; // High pitch
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else {
                osc.frequency.value = 200; // Low pitch
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            }
        }

    </script>
</body>
</html>
